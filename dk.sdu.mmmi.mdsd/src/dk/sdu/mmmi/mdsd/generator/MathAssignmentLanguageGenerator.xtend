/*
 * generated by Xtext 2.12.0
 */
package dk.sdu.mmmi.mdsd.generator

import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.Addition
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.Division
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.EvaluateExpression
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.ExternalDeclaration
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.ExternalReference
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.Literal
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.Multiplication
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.Parameter
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.Root
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.Subtraction
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.VariableDeclaration
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.VariableReference
import java.util.ArrayList
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

import static extension org.eclipse.xtext.EcoreUtil2.getAllContainers
import static extension org.eclipse.xtext.EcoreUtil2.getAllContentsOfType
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.Expression

/**
 * Generates code from the model files on save.
 */
class MathAssignmentLanguageGenerator extends AbstractGenerator {
	
	public static val GEN_FILE_EXT = ".java"
	public static val GEN_DIR = "math/"
	public static val GEN_FILE_NAME = "MathComputation"
	
	var Root root

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		root = resource.allContents.filter(Root).head
		
		val dir = GEN_DIR
		val pkg = dir.replaceAll("/", ".").substring(0, dir.length - 1) // convert path to package by converting all '/' to '.', and remove trailing '.'
		val fileName = GEN_FILE_NAME
		
		fsa.generateFile(dir + fileName + GEN_FILE_EXT, root.generateClass(pkg, fileName))
	}
    
	def generateClass(Root root, String pkg, String name)'''
		«generateHeader»
		package «pkg»;
		
		public class «name» {
		
			public static interface Externals {
				
				«FOR external : root.elements.filter(ExternalDeclaration)»
					«external.generateMethod»;
					
				«ENDFOR»
			}
			
			private Externals externals;
			
			public «name»(Externals _externals) {
				externals = _externals;
			}
			
			public void compute() {
				«FOR evaluate : root.elements.filter(EvaluateExpression)»
					«evaluate.generateComputation»
				«ENDFOR»
			}
			
			«root.generateNestedInnerClass»
		}
	'''
	
	/**
	 * Iterates through an EObject's variable declaration children and generates nested inner classes for them.
	 */
	def <T extends EObject> generateNestedInnerClass(T parent)'''
		«FOR declaration: parent.getDirectChildren(VariableDeclaration)»
			«declaration.generateInnerClass»
			
		«ENDFOR»
	'''
	
	/**
	 * Recursively generates inner classes for variable declarations.
	 */
	def CharSequence generateInnerClass(VariableDeclaration declaration)'''
		class «declaration.generateInnerClassName» {
			
			private final int «declaration.name» = «declaration.generateAssignment»;
			
			public int compute() {
				return «declaration.in.generate»;
			}
			
			«declaration.generateNestedInnerClass»
		}
	'''
	
	def generateAssignment(VariableDeclaration declaration) {
		declaration.assignment.resolveReference(declaration.parent, declaration)
		declaration.assignment.generate
	}
	
	/**
	 * Ensures that the variable references in the generated code for an expression of the type:
	 * 		let x = 5 in let x = x
	 * can be resolved properly, by telling Java it should look in the outer classes for the last 'x', 
	 * as it isn't a self-reference.
	 */
	def void resolveReference(Expression ref, VariableDeclaration candidate, VariableDeclaration original) {
		if (ref === null || candidate === null) {
			return
		}
		if (ref instanceof VariableReference) {
			if (ref.variable.name == original.name && candidate.name == ref.variable.name && candidate != original) {
				ref.variable.name = '''«candidate.generateInnerClassName».this.«ref.variable.name»'''
			}
			else {
				resolveReference(ref, candidate.parent, original) // current candidate didn't satisfy conditions, try to resolve with parent
			}
		}
		ref.getDirectChildren(VariableReference).forEach[resolveReference(candidate, original)] // resolve direct children in the expression
	}
	
	def generateInnerClassName(VariableDeclaration declaration) {
		val name = root.indexOf(declaration).toString.replace("->", "_")
		'''Let«name»'''
	}
	
	def generateMethod(ExternalDeclaration dec)
		'''public int «dec.generateMethodSignature»'''
	
	def generateMethodSignature(ExternalDeclaration dec)
		'''«dec.name»«dec.parameters.generateParameters»'''
	
	def generateParameters(Parameter... params)
		'''(«FOR param : params SEPARATOR ', '»«param.type» «param.name»«ENDFOR»)'''
	
	def generateComputation(EvaluateExpression evaluate)
		'''System.out.println(«evaluate.generate»);'''
	
	def generateHeader()'''
		/**
		 * Generated by MathAssignmentLanguage
		 */
 	'''
	
	// Start of recursive multi-dispatch methods for displaying an arithmetic expression's complete syntax tree
	
	def dispatch CharSequence generate(EvaluateExpression element)
		'''"«element.label» " + «element.expression.generate»'''
	
	def dispatch CharSequence generate(Addition expression)
		'''(«expression.left.generate» + «expression.right.generate»)'''
	
	def dispatch CharSequence generate(Subtraction expression)
		'''(«expression.left.generate» - «expression.right.generate»)'''
	
	def dispatch CharSequence generate(Multiplication expression)
		'''(«expression.left.generate» * «expression.right.generate»)'''
	
	def dispatch CharSequence generate(Division expression)
		'''(«expression.left.generate» / «expression.right.generate»)'''
	
	def dispatch CharSequence generate(VariableDeclaration declaration)
		'''new «declaration.generateInnerClassName»().compute()'''
	
	def dispatch CharSequence generate(VariableReference reference)
		'''«reference.variable.name»'''
	
	def dispatch CharSequence generate(ExternalReference reference)
		'''externals.«reference.external.name»(«FOR argument : reference.arguments SEPARATOR ', '»«argument.generate»«ENDFOR»)'''
	
	def dispatch generate(Literal expression)
		'''«expression.value»'''
	
	// Start of methods for navigating the tree structure of the metamodel.
	
	/**
     * Recursively searches through all children in the input object for the target VariableDeclaration 
     * using a depth-first search.
     * 
     * Returns nested pairs of integers representing the nested and parallel structure
     * of the target VariableDeclaration's location in the tree structure.
	 */
    def <T extends EObject> indexOf(T input, VariableDeclaration target) {
    	val children = input.eAllContents
		var outerIndex = 0
    	while (children.hasNext) {
    		val candidate = children.next
    		if (candidate === target) {
    			return outerIndex
    		}
    		if (candidate instanceof VariableDeclaration || candidate instanceof EvaluateExpression) {
    			children.prune // removes all elements nested in the last result of ::next (but keeps those parallel)
    			val innerIndex = candidate.indexOf(target)
    			if (innerIndex !== null) {
    				return outerIndex -> innerIndex
    			}
    			outerIndex++
    		}
		}
    }
    
    /**
     * Returns the first object of type found, and any objects of type that are
     * parallel / at the same depth of nesting as the first one found.
     */
    def <T extends EObject> getDirectChildren(EObject input, Class<T> type) {
    	val children = input.eAllContents
    	val results = new ArrayList<T>()
    	while (children.hasNext) {
    		val candidate = children.next
    		if (type.isInstance(candidate)) {
    			children.prune // removes all elements nested in the last result of ::next (but keeps those parallel)
    			results.add(type.cast(candidate))
    		}
    	}
    	return results
    }
    
    /**
     * Returns the closest container of type VariableDeclaration for the input.
     */
    def getParent(VariableDeclaration input) {
    	input.allContainers.filter(VariableDeclaration).head
    }
	
}
