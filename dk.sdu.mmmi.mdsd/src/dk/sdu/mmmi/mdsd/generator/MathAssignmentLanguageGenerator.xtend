/*
 * generated by Xtext 2.12.0
 */
package dk.sdu.mmmi.mdsd.generator

import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.Addition
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.Division
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.EvaluateExpression
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.Expression
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.ExternalDeclaration
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.ExternalReference
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.Literal
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.Multiplication
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.Parameter
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.Root
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.Subtraction
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.VariableDeclaration
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.VariableReference
import java.util.HashSet
import java.util.List
import java.util.Set
import java.util.concurrent.CopyOnWriteArrayList
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

import static extension org.eclipse.xtext.EcoreUtil2.getAllContainers
import static extension org.eclipse.xtext.EcoreUtil2.getAllContentsOfType
import java.util.HashMap
import java.util.Map
import java.util.ArrayList
import org.eclipse.emf.ecore.EObject

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MathAssignmentLanguageGenerator extends AbstractGenerator {
	
	public static val GEN_FILE_EXT = ".java"
	
	public static val GEN_DIR = "math/"
	public static val GEN_FILE_NAME = "MathComputation"
	
	/**
	 * Data structure the represents the nested structure and scope of 'let in's.
	 * The outer list mimics the scope of each 'let in' that is not declared inside another,
	 * and the inner list mimics the nested structure of the outer 'let in'.
	 */
	//val List<List<VariableDeclaration>> variableDeclarations = new CopyOnWriteArrayList()
	val variableTree = new Tree()

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val root = resource.allContents.filter(Root).head
		
		val dir = GEN_DIR
		val pkg = dir.replaceAll("/", ".").substring(0, dir.length - 1) // convert path to package by converting all '/' to '.', and remove trailing '.'
		val fileName = GEN_FILE_NAME
		
		//variableDeclarations.clear
		//variableDeclarations.add(new CopyOnWriteArrayList())
		
		variableTree.clear
		
		resource.allContents.filter(EvaluateExpression).forEach[variableTree.add(collectVariableDeclarations)]
		
		fsa.generateFile(dir + fileName + GEN_FILE_EXT, root.generateClass(pkg, fileName))
	}
	
	static class Tree {
		List<Node> roots = new ArrayList()
		
		def clear() {
			roots.clear
		}
		
		def add(Node node) {
			roots.add(node)
		}
		
		def find(VariableDeclaration dec) {
			for(root : roots) {
				val a = root.find(dec)
				if(a!=-1) {
					return a
				}
			}
		}
		
	}
	
	static class Node {
    VariableDeclaration data //if null = root
    List<Node> childs = new ArrayList() //if empty == leaf
    
    	new() {
    	}
    
    	new(VariableDeclaration dec) {
    		data = dec
    	}

        def add(VariableDeclaration dec) {
            val addedNode = new Node(dec)
            childs.add(addedNode)
            return addedNode
        }
        
        def find(VariableDeclaration dec) {
        	
        	for (var i = 0; i < childs.size; i++) {
        		if (childs.get(i).data == dec) {
        			return i
        		}
        		else {
        			val a = childs.get(i).find(dec)
        			if (a != -1) {
        				return i -> a
        			}
        		}
        	}
        	return -1
        }
        
        def print() {
        	println('data: ' + data + ' \n childs:')
        	childs.forEach[println(it)]
        }
        
        override toString() {
        	return 'data: ' + data + ' \n childs: ' + childs
        }

	}
	
	/**
	 * This method acts as a local state for the tail recursive method "collectVariableDeclaration", 
	 * as it contains the accumulated seenContainerSizes.
	 */
	def collectVariableDeclarations(EvaluateExpression expression) {
		val root = new Node()
		coll(expression, root)
		root.print
		root
	}
	
	def coll(EObject input, Node node) {
		if(input === null) {
			return;
		}
		//list = input.allContentsofType(VariableDeclaration)
	    val contents = input.eAllContents//.filter(VariableDeclaration)
	    if (contents.empty) {
	    	println(input + ' had empty list')
	        return;
	    }
	    while(contents.hasNext) {
			var element = contents.next
			if (element instanceof VariableDeclaration) {
				contents.prune
				//add to current branch -- nest class
				val addedNode = node.add(element) //node.childs.last
				println('input: ' + input)
			
				coll(element, addedNode) // nesting -> keep adding as childs
				
				/*while (contents.hasNext) {
					println('parallel')
					val next = contents.next() //previously .get(1) (think that would only support 2 childs)
					println('next: ' + next)
					val addedN = node.add(next)
					//prepare new branch -- new parallel class
					coll(next as Expression, node) // parallel -> keep adding to current node
				}*/
			}
		}
	}
	
	/**
	 * Tail recursive method that goes through all VariableDeclarations. If a VariableDeclaration is met 
	 * with the same layer/depth of nesting as a previous one, a new collection is created (as these should 
	 * not share scope), and all future VariableDeclarations are added to that list, until another VariableDeclaration 
	 * is met with the same depth of nesting.
	 */
	 /*@Deprecated
	def private void collectVariableDeclaration(Iterable<VariableDeclaration> declarations, Set<Integer> seenContainerSizes) {
		val head = declarations.head
		val tail = declarations.tail
		
		if (!seenContainerSizes.add(head.allContainers.size)) {
			val List<VariableDeclaration> inner = new CopyOnWriteArrayList()
			inner.add(head)
			variableDeclarations.add(inner)
		}
		else {
			variableDeclarations.last.add(head)
		}
		if (!tail.empty) {
			tail.collectVariableDeclaration(seenContainerSizes)
		}
	}*/
	
	/**
	 * Helper method that allows searching for elements that are nested one layer.
	 * Returns the index of both the outer and inner collections.
	 */
	def getIndex(List<List<VariableDeclaration>> container, VariableDeclaration target) {
		for (i : 0 ..< container.size) {
			val list = container.get(i)
			val index = list.indexOf(target)
			if (index != -1) {
				return i -> index
			}
		}
		return -1 -> -1
	}
	
	def generateClass(Root root, String pkg, String name)'''
		«generateHeader»
		package «pkg»;
		
		public class «name» {
		
			public static interface Externals {
				
				«FOR external : root.elements.filter(ExternalDeclaration)»
					«external.generateMethod»;
					
				«ENDFOR»
			}
			
			private Externals externals;
			
			public «name»(Externals _externals) {
				externals = _externals;
			}
			
			public void compute() {
				«FOR evaluate : root.elements.filter(EvaluateExpression)»
					«evaluate.generateComputation»
				«ENDFOR»
			}
			
			«FOR declarations : variableTree.roots»
				«declarations.generateInnerClass»
				
			«ENDFOR»
		}
	'''
	
	/**
	 * Recursively generates nested inner classes for 'let in's.
	 */
	def CharSequence generateInnerClass(Node node) {
		if (node.data === null) {
			return
				'''
					«FOR dec: node.childs»
						«dec.generateInnerClass»
					«ENDFOR»
				'''
		}
		
		'''
			class «node.data.generateInnerClassName» {
				
				private final int «node.data.name» = «node.data.generateAssignment»;
				
				public int compute() {
					return «node.data.in.generate»;
				}
				
				«FOR declaration : node.childs»
					«declaration.generateInnerClass»
					
				«ENDFOR»
			}
		'''
		/*
				«IF !tail.isEmpty»
					«tail.generateInnerClass»
					* «ENDIF»
					*/
	}
	
	/**
	 * Makes sure that the generated code for an expression of the type:
	 * 		let x = 5 in let x = x end end
	 * can be resolved properly, by telling Java it should look in the outer class for the last 'x'.
	 */
	def generateAssignment(VariableDeclaration head) {
		/*val expression = head.assignment
		val declarations = variableDeclarations.get(variableDeclarations.getIndex(head).key)
		expression.getAllContentsOfType(VariableReference).filter[variable.name == head.name].forEach[
			val ref = it
			val target = declarations.takeWhile[it !== head].findLast[name == ref.variable.name]
			variable.name = '''«target.generateInnerClassName».this.«variable.name»'''
		]*/
		//expression.generate
		head.assignment.generate
	}
	
	def generateInnerClassName(VariableDeclaration declaration) {
		/*val indices = variableDeclarations.getIndex(declaration)
		'''Let«indices.key»_«indices.value»'''*/
		val name = variableTree.find(declaration).toString.replace("->", "_")
		'''Let«name»'''
	}
	
	def generateMethod(ExternalDeclaration dec)
		'''public int «dec.generateMethodSignature»'''
	
	def generateMethodSignature(ExternalDeclaration dec)
		'''«dec.name»«dec.parameters.generateParameters»'''
	
	def generateParameters(Parameter... params)
		'''(«FOR param : params SEPARATOR ', '»«param.type» «param.name»«ENDFOR»)'''
	
	def generateComputation(EvaluateExpression evaluate)
		'''System.out.println(«evaluate.generate»);'''
	
	def generateHeader()'''
		/**
		 * Generated by MathAssignmentLanguage
		 */
 	'''
	
	/**
	 * Start of recursive multi-dispatch methods for displaying an arithmetic expression's complete syntax tree
	 */
	def dispatch CharSequence generate(EvaluateExpression element)
		'''"«element.label» " + «element.expression.generate»'''
	
	def dispatch CharSequence generate(Addition expression)
		'''(«expression.left.generate» + «expression.right.generate»)'''
	
	def dispatch CharSequence generate(Subtraction expression)
		'''(«expression.left.generate» - «expression.right.generate»)'''
	
	def dispatch CharSequence generate(Multiplication expression)
		'''(«expression.left.generate» * «expression.right.generate»)'''
	
	def dispatch CharSequence generate(Division expression)
		'''(«expression.left.generate» / «expression.right.generate»)'''
	
	def dispatch CharSequence generate(VariableDeclaration declaration)
		'''new «declaration.generateInnerClassName»().compute()'''
	
	def dispatch CharSequence generate(VariableReference reference)
		'''«reference.variable.name»'''
	
	def dispatch CharSequence generate(ExternalReference reference)
		'''externals.«reference.external.name»(«FOR argument : reference.arguments SEPARATOR ', '»«argument.generate»«ENDFOR»)'''
	
	def dispatch generate(Literal expression)
		'''«expression.value»'''
	
}