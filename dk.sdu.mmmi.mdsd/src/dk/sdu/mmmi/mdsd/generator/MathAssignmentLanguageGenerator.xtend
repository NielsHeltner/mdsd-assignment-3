/*
 * generated by Xtext 2.12.0
 */
package dk.sdu.mmmi.mdsd.generator

import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.Addition
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.Division
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.EvaluateExpression
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.ExternalDeclaration
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.ExternalReference
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.Literal
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.Multiplication
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.Parameter
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.Root
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.Subtraction
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.VariableDeclaration
import dk.sdu.mmmi.mdsd.mathAssignmentLanguage.VariableReference
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

import static extension org.eclipse.xtext.EcoreUtil2.getAllContentsOfType

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MathAssignmentLanguageGenerator extends AbstractGenerator {
	
	public static val GEN_FILE_EXT = ".java"
	
	public static val GEN_DIR = "math/"
	public static val GEN_FILE_NAME = "MathComputation"
	
	/**
	 * Data structure the represents the nested structure and scope of 'let in's.
	 * The outer list mimics the scope of each 'let in' that is not declared inside another,
	 * and the inner list mimics the nested structure of the outer 'let in'.
	 */
	var Node<VariableDeclaration> variableTree

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val root = resource.allContents.filter(Root).head
		
		val dir = GEN_DIR
		val pkg = dir.replaceAll("/", ".").substring(0, dir.length - 1) // convert path to package by converting all '/' to '.', and remove trailing '.'
		val fileName = GEN_FILE_NAME

		variableTree = new Node
		resource.allContents.filter(EvaluateExpression).forEach[collectVariableDeclarations]
		
		fsa.generateFile(dir + fileName + GEN_FILE_EXT, root.generateClass(pkg, fileName))
	}
	
	/**
	 * This method acts as a local state for the tail recursive method "collectVariableDeclaration", 
	 * as it contains the accumulated seenContainerSizes.
	 */
	def collectVariableDeclarations(EvaluateExpression expression) {
		val root = new Node<VariableDeclaration>(variableTree)
		collectVariableDeclaration(expression, root)
		variableTree.childs.add(root)
	}
	
	/**
	 * Tail recursive method that goes through all VariableDeclarations. If a VariableDeclaration is met 
	 * with the same layer/depth of nesting as a previous one, a new collection is created (as these should 
	 * not share scope), and all future VariableDeclarations are added to that list, until another VariableDeclaration 
	 * is met with the same depth of nesting.
	 */
	def void collectVariableDeclaration(EObject input, Node<VariableDeclaration> node) {
	    val contents = input.eAllContents//.filter(VariableDeclaration)
	    while(contents.hasNext) {
			var element = contents.next
			if (element instanceof VariableDeclaration) {
				contents.prune
				//add to current branch -- nest class
				val addedNode = node.add(element) //node.childs.last
				println('input: ' + input)
			
				collectVariableDeclaration(element, addedNode) // nesting -> keep adding as childs
				
				/*while (contents.hasNext) {
					println('parallel')
					val next = contents.next() //previously .get(1) (think that would only support 2 childs)
					println('next: ' + next)
					val addedN = node.add(next)
					//prepare new branch -- new parallel class
					coll(next as Expression, node) // parallel -> keep adding to current node
				}*/
			}
		}
	}
	
	def generateClass(Root root, String pkg, String name)'''
		«generateHeader»
		package «pkg»;
		
		public class «name» {
		
			public static interface Externals {
				
				«FOR external : root.elements.filter(ExternalDeclaration)»
					«external.generateMethod»;
					
				«ENDFOR»
			}
			
			private Externals externals;
			
			public «name»(Externals _externals) {
				externals = _externals;
			}
			
			public void compute() {
				«FOR evaluate : root.elements.filter(EvaluateExpression)»
					«evaluate.generateComputation»
				«ENDFOR»
			}
			
			«FOR declarations : variableTree.childs»
				«declarations.generateInnerClass»
			«ENDFOR»
		}
	'''
	
	/**
	 * Recursively generates inner classes for 'let in's.
	 */
	def CharSequence generateInnerClass(Node<VariableDeclaration> node) {
		if (node.data === null) {
			return node.generateNestedInnerClass
		}
		'''
			class «node.data.generateInnerClassName» {
				
				private final int «node.data.name» = «node.data.generateAssignment»;
				
				public int compute() {
					return «node.data.in.generate»;
				}
				
				«node.generateNestedInnerClass»
			}
		'''
	}
	
	/**
	 * Iterates through a Node's children and generates nested inner classes for them.
	 */
	def generateNestedInnerClass(Node<VariableDeclaration> node)'''
		«FOR declaration: node.childs»
			«declaration.generateInnerClass»
			
		«ENDFOR»
	'''
	
	/**
	 * Makes sure that the generated code for an expression of the type:
	 * 		let x = 5 in let x = x end end
	 * can be resolved properly, by telling Java it should look in the outer class for the last 'x'.
	 */
	def generateAssignment(VariableDeclaration dec) { // TODO: refactor this method
		/*val expression = head.assignment
		val declarations = variableDeclarations.get(variableDeclarations.getIndex(head).key)
		expression.getAllContentsOfType(VariableReference).filter[variable.name == head.name].forEach[
			val ref = it
			val target = declarations.takeWhile[it !== head].findLast[name == ref.variable.name]
			variable.name = '''«target.generateInnerClassName».this.«variable.name»'''
		]*/
		//expression.generate
		
		
		val expression = dec.assignment
		//bug: hvis expression i sig selv er en VariableReference så kommer den ikke med i forEach
		expression.getAllContentsOfType(VariableReference).filter[variable.name == dec.name].forEach[
			var candidateNode = variableTree.nodeOf(dec).parent
			var VariableDeclaration target = null
			while (target === null) {
				if (candidateNode.data.name == variable.name) {
					target = candidateNode.data
					variable.name = '''«target.generateInnerClassName».this.«variable.name»'''
				}
				candidateNode = candidateNode.parent
			}
		]
		expression.generate
	}
	
	def generateInnerClassName(VariableDeclaration declaration) {
		val name = variableTree.indexOf(declaration).toString.replace("->", "_")
		'''Let«name»'''
	}
	
	def generateMethod(ExternalDeclaration dec)
		'''public int «dec.generateMethodSignature»'''
	
	def generateMethodSignature(ExternalDeclaration dec)
		'''«dec.name»«dec.parameters.generateParameters»'''
	
	def generateParameters(Parameter... params)
		'''(«FOR param : params SEPARATOR ', '»«param.type» «param.name»«ENDFOR»)'''
	
	def generateComputation(EvaluateExpression evaluate)
		'''System.out.println(«evaluate.generate»);'''
	
	def generateHeader()'''
		/**
		 * Generated by MathAssignmentLanguage
		 */
 	'''
	
	/**
	 * Start of recursive multi-dispatch methods for displaying an arithmetic expression's complete syntax tree
	 */
	def dispatch CharSequence generate(EvaluateExpression element)
		'''"«element.label» " + «element.expression.generate»'''
	
	def dispatch CharSequence generate(Addition expression)
		'''(«expression.left.generate» + «expression.right.generate»)'''
	
	def dispatch CharSequence generate(Subtraction expression)
		'''(«expression.left.generate» - «expression.right.generate»)'''
	
	def dispatch CharSequence generate(Multiplication expression)
		'''(«expression.left.generate» * «expression.right.generate»)'''
	
	def dispatch CharSequence generate(Division expression)
		'''(«expression.left.generate» / «expression.right.generate»)'''
	
	def dispatch CharSequence generate(VariableDeclaration declaration)
		'''new «declaration.generateInnerClassName»().compute()'''
	
	def dispatch CharSequence generate(VariableReference reference)
		'''«reference.variable.name»'''
	
	def dispatch CharSequence generate(ExternalReference reference)
		'''externals.«reference.external.name»(«FOR argument : reference.arguments SEPARATOR ', '»«argument.generate»«ENDFOR»)'''
	
	def dispatch generate(Literal expression)
		'''«expression.value»'''
	
}